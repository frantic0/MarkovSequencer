<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
</head>

<body>
  <div style="margin: 30px 30px 30px 30px;">
    <h1>Markov Sequencer</h1>
    <!-- <p>Markov &gt; Files</p> -->

    <div>
      <p>Markov Generator</p>
      <textarea id="ta_patterns" value="" cols="40" rows="5" onkeyup="getPatternChanges()"></textarea>
    </div>
    <div>
      <button type="button" id="btn1" onclick="btn1_loadData()">LOAD DATA</button>
      <!-- <button type="button" id="btn2" onclick="btn2_train()">TRAIN</button> -->
      <button type="button" id="btn3" onclick="btn3_delete()">DELETE</button>
    </div>
    <div>
      <p>Sequence</p>
      <textarea id="ta_sequence" value="sdfsdf" cols="40" rows="5" onkeyup="getSeqChanges()"></textarea>
    </div>
    <button type="button" id="btn4" onclick="btn4_addData()">ADD DATA</button>
    <button type="button" id="btn5" onclick="btn5_generate()">GENERATE</button>

    <p></p>
    &nbsp;
    &nbsp;
    <div>
      <div>
        <div style="float: left; margin-right: 10px">playing &gt; </div>
        <div style="float: left;" id="console"> </div>
      </div>

      <div style="clear:left;">
        <div style="float: left; margin-right: 10px">gen &gt; </div>
        <div style="float: left;" id="gen_console"> </div>
      </div>
    </div>
  </div>

  <!--<div id="console"></div>-->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.14.1/dist/tf.min.js"></script>

</body>
<script src="./maxiLib.js"></script>
<!-- <script src="https://nickersoft.github.io/markov.js/node_modules/markov.js/markov.min.js"></script> -->
<script src="./markov.min.js"></script>
<script>
  /// Markov Model //////////////////////////////////

  var markov = new Markov();


  /// Global vars (hackit!)  //////////////////////////////////

  var patterns = "kccc bcc bcc kccs bcc kccs kccs bcc kcco kccs skos kkok ccs koss kssooc bcc skos asks";
  var sequence = "kc kc k shos";
  // var sequence = "ksc-cccckc-k-shos";

  var modelOutput = "";

  /// UI handlers //////////////////////////////////

  function setup() {
    document.getElementById("ta_patterns").value = patterns;
    markov.add(patterns);
    document.getElementById("ta_sequence").value = sequence;
    document.getElementById("console").innerHTML = sequence;
  }
  setup();

  /* Grab text sequence */
  function getSeqChanges() {
    sequence = document.getElementById("ta_sequence").value;
    document.getElementById("console").innerHTML = sequence;
    console.log(sequence);


  }

  function getPatternChanges() {
    patterns = document.getElementById("ta_patterns").value;
    document.getElementById("ta_patterns").innerHTML = patterns;
  }

  function btn1_loadData() {
    patterns = document.getElementById("source").value;
    markov = new Markov();
    markov.add(patterns);
  }

  function btn2_train() {
    console.log(patterns);
  }

  function btn3_delete() {
    patterns = "";
    document.getElementById("ta_patterns").value = patterns;
    markov = new Markov();
  }

  function btn4_addData() {
    // patterns += sequence + "&#013;&#010;"; // to add breakline to text content of TextArea
    markov.add(sequence);
    patterns += " " + sequence;
    document.getElementById("ta_patterns").value = patterns;
  }


  function btn5_generate() {
    sequence = markov.generate();
    document.getElementById("console").innerHTML = sequence;
  }

  /// Maxi Audio Engine  //////////////////////////////////

  var maxiAudio = new maximJs.maxiAudio();

  var clock = new maximJs.maxiOsc();

  var kick = new maximJs.maxiSample();
  var snare = new maximJs.maxiSample();
  var closedHat = new maximJs.maxiSample();
  var openHat = new maximJs.maxiSample();

  var mySine = new maximJs.maxiOsc();
  var myOtherSine = new maximJs.maxiOsc();
  var myLastSine = new maximJs.maxiOsc();

  var oldClock = 0;
  var phase = 0;

  maxiAudio.init();

  // 	var sample = new maximJs.maxiSample();
  maxiAudio.loadSample("./samples/909b.wav", kick);
  maxiAudio.loadSample("./samples/909.wav", snare);
  maxiAudio.loadSample("./samples/909closed.wav", closedHat);
  maxiAudio.loadSample("./samples/909open.wav", openHat);


  function loopPlayer(){

    // // Web Audio Equivalent
    // var audioContext = new AudioContext();
    // var futureTickTime = audioContext.currentTime;
    // function scheduler() {
    //   if (futureTickTime < audioContext.currentTime + 0.1) {
    //     futureTickTime += 0.5; //____can be any time value. 0.5 happens to be a quarter note at 120 bpm
    //     console.log(futureTickTime);
    // }
    //   window.setTimeout(scheduler, 0);
    // }
    // scheduler();

    var now = clock.sinewave(7);

    // DEBUG:
    // console.log("phase:" + phase);
    // console.log("now:" + now);
    // console.log("oldClock:" + oldClock);

    if (oldClock <= 0 && now > 0) {

      var sampleSelector = sequence[phase++ % sequence.length];

      switch (sampleSelector) {
        case "k":
          kick.trigger();
          break;
        case "s":
          snare.trigger();
          break;
        case "o":
          openHat.trigger();
          break;
        case "c":
          closedHat.trigger();
          break;
      }
    }

    oldClock = now;

    var w = 0.0;

    if (kick.isReady()) {
      w += kick.playOnce();
    }
    if (snare.isReady()) {
      w += snare.playOnce();
    }
    if (closedHat.isReady()) {
      w += closedHat.playOnce();
    }
    if (openHat.isReady()) {
      w += openHat.playOnce();
    }
    return w;
  }

  function synComposer(n) {

  }


  function synSelector(n) {

    var sinOut;

    switch (n) {
      case 0:
        sinOut = mySine.sinewave(myOtherSine.sinewave(0.1) * 440);
        break;
      case 1:
        sinOut = mySine.sinewave(myOtherSine.sinewave(30) * 440);
        break;
      case 2:
        sinOut = mySine.sinewave(myOtherSine.sinewave(myLastSine.sinewave(0.1) * 30) * 440);
        break;
      default:
        sinOut = mySine.sinewave(myOtherSine.sinewave(myLastSine.sinewave(0.1) * 30) * 440);
    }
    return sinOut;
  }

  function mixer(){
    return loopPlayer() + synSelector(parseInt(sequence));
  }

  function play() {
    maxiAudio.play = function() {
      this.output = mixer();
    };
  };

  play();

  // function play() {
  //   maxiAudio.play = function() {
  //
  //     var now = clock.sinewave(7);
  //
  //     if (oldClock <= 0 && now > 0) {
  //
  //       var sampleSelector = sequence[phase++ % sequence.length];
  //
  //       switch (sampleSelector) {
  //         case "k":
  //           kick.trigger();
  //           break;
  //         case "s":
  //           snare.trigger();
  //           break;
  //         case "o":
  //           openHat.trigger();
  //           break;
  //         case "c":
  //           closedHat.trigger();
  //           break;
  //       }
  //     }
  //
  //     oldClock = now;
  //
  //     var w = 0.0;
  //
  //     if (kick.isReady()) {
  //       w += kick.playOnce();
  //     }
  //     if (snare.isReady()) {
  //       w += snare.playOnce();
  //     }
  //     if (closedHat.isReady()) {
  //       w += closedHat.playOnce();
  //     }
  //     if (openHat.isReady()) {
  //       w += openHat.playOnce();
  //     }
  //     this.output = w + synSelector(parseInt(sequence));
  //   };
  //
  // };

</script>

</html>
