/**
 * Markov
 * =======
 * A small library for generating strings using Markov chains
 *
 * License
 * -------
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Tyler Nickerson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @preserve
 */
(function(global,factory){"use strict";if(typeof define==="function"&&define.amd){define(function(){return factory(global,global.document)})}else if(typeof module!=="undefined"&&module.exports){module.exports=factory(global,global.document)}else{global.Markov=factory(global,global.document)}})(typeof window!=="undefined"?window:this,function(w,d){var Markov=function(){var PROCESSING_MAX_TIME=100,PROCESSING_WAIT_TIME=20,self=this,strings={beginning:[],ending:[],mappings:{}},prevString="",isString=function(obj){return String(obj)===obj},isArray=function(obj){return obj.constructor===Array},getRandomString=function(array){return array[Math.floor(array.length*Math.random())]},trim=function(string){return string.replace(/^\s+|\s+$/g,"")},count=function(dict){var count=0;for(key in dict){if(dict.hasOwnProperty(key))count++}return count},loadURL=function(url,onSuccess,onError){var xhr,rtext;xhr=typeof XMLHttpRequest!="undefined"?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP");xhr.open("get",url,true);xhr.onreadystatechange=function(){var status,data;if(xhr.readyState==4){status=xhr.status;if(status==200){rtext=xhr.responseText;try{data=JSON.parse(rtext)}catch(e){data=rtext.split("\n")}loadArray(data,onSuccess)}else{onError&&onError(status);throw"Could not complete ajax request: errored with status code "+status+"\n See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status "+"for more information"}}};xhr.send()},loadArray=function(array,callback){var queue;queue=array.concat();setTimeout(function(){var endtime=+new Date+PROCESSING_MAX_TIME;do{chunk=queue.shift();self.add(chunk)}while(queue.length>0);if(queue.length>0){setTimeout(arguments.callee,PROCESSING_WAIT_TIME)}else{callback.call(self)}},PROCESSING_WAIT_TIME)};self.load=function(){if(arguments.length>0){if(isArray(arguments[0])){loadArray(arguments[0],arguments[1])}else if(isString(arguments[0])){loadURL(arguments[0],arguments[1],arguments[2])}else{throw"Invalid argument type. load() requires either an array of strings or the path to a "+"JSON data file."}}else{throw"No argument given. load() requires either an array of strings or the path to a "+"JSON data file."}};self.add=function(string){var trimmed=trim(string);if(trimmed.length>0){words=trim(string).split(" ");strings.beginning.push(words[0]);strings.ending.push(words[words.length-1]);for(i=0;i<words.length;i++){var current_word,next_word;current_word=words[i];next_word=words[i+1];if(next_word!==undefined){if(strings.mappings.hasOwnProperty(current_word)){strings.mappings[current_word].push(next_word)}else{strings.mappings[current_word]=[next_word]}}}return true}return false};self.generate=function(){if(count(strings.mappings)<=0){throw"No strings to generate from (did you forget a load() call?)"}else{var word,string,return_str;word=getRandomString(strings.beginning);string=[word];while(strings.mappings.hasOwnProperty(word)){word=getRandomString(strings.mappings[word]);string.push(word)}return_str=string.join(" ");if(return_str.length==0||return_str==prevString){return_str=self.generate()}prevString=return_str;return return_str}};if(arguments.length>0){self.load.apply(this,arguments)}};return Markov});